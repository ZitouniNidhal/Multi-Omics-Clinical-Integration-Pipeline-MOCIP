"""
Module d'export vers format CSV standardisé - Version simplifiée pour livraison rapide
"""
import pandas as pd
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

class CSVExporter:
    """Exporte les données vers CSV avec standards biomédicaux - Version accélérée"""
    
    def __init__(self, separator: str = '\t', include_header: bool = True):
        self.separator = separator
        self.include_header = include_header
        self.logger = logging.getLogger('CSVExporter')
    
    def export_standard_csv(self, data: pd.DataFrame, 
                           output_path: str,
                           metadata: Optional[Dict[str, Any]] = None) -> bool:
        """
        Exporte les données vers CSV avec métadonnées
        
        Args:
            data: Données à exporter
            output_path: Chemin de sortie
            metadata: Métadonnées à inclure
        
        Returns:
            True si succès, False sinon
        """
        self.logger.info(f"Export CSV vers {output_path}")
        
        try:
            # Créer les lignes de métadonnées
            metadata_rows = []
            if metadata:
                metadata_rows.append(f"# Metadata: {metadata}")
            
            metadata_rows.extend([
                f"# Export date: {datetime.now().isoformat()}",
                f"# Dataset: {len(data)} samples, {len(data.columns)} features",
                f"# Generated by: Multi-Omics Pipeline v1.0"
            ])
            
            # Écrire les métadonnées en en-tête
            with open(output_path, 'w', encoding='utf-8') as f:
                for row in metadata_rows:
                    f.write(row + '\n')
            
            # Ajouter les données
            data.to_csv(output_path, 
                       sep=self.separator,
                       header=self.include_header,
                       index=False,
                       mode='a',  # Append mode
                       encoding='utf-8')
            
            self.logger.info(f"✅ Export CSV terminé : {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Erreur lors de l'export CSV : {e}")
            return False
    
    def export_with_data_dictionary(self, data: pd.DataFrame, 
                                   output_path: str,
                                   data_dictionary: Optional[Dict[str, str]] = None) -> bool:
        """
        Exporte avec un dictionnaire de données
        
        Args:
            data: Données à exporter
            output_path: Chemin de sortie
            data_dictionary: Description des colonnes
        
        Returns:
            True si succès, False sinon
        """
        self.logger.info(f"Export CSV avec dictionnaire vers {output_path}")
        
        try:
            # Créer le dictionnaire de données si non fourni
            if data_dictionary is None:
                data_dictionary = self._generate_data_dictionary(data)
            
            # Créer les lignes de description
            description_rows = []
            description_rows.append("# Data Dictionary:")
            description_rows.append("# Column_Name\tDescription\tData_Type\tExample")
            
            for col in data.columns:
                description = data_dictionary.get(col, f"{col} - Description not provided")
                dtype = str(data[col].dtype)
                example = str(data[col].dropna().iloc[0]) if not data[col].dropna().empty else "N/A"
                
                description_rows.append(f"# {col}\t{description}\t{dtype}\t{example}")
            
            # Écrire les descriptions
            with open(output_path, 'w', encoding='utf-8') as f:
                for row in description_rows:
                    f.write(row + '\n')
                
                # Ligne vide avant les données
                f.write('\n')
            
            # Ajouter les données
            data.to_csv(output_path, 
                       sep=self.separator,
                       header=self.include_header,
                       index=False,
                       mode='a',
                       encoding='utf-8')
            
            self.logger.info(f"✅ Export CSV avec dictionnaire terminé : {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Erreur lors de l'export CSV avec dictionnaire : {e}")
            return False
    
    def export_split_by_type(self, data: pd.DataFrame, 
                           output_dir: str,
                           type_column: str = 'data_type') -> bool:
        """
        Exporte les données séparées par type dans différents fichiers
        
        Args:
            data: Données à exporter
            output_dir: Répertoire de sortie
            type_column: Colonne pour séparer les données
        
        Returns:
            True si succès, False sinon
        """
        self.logger.info(f"Export séparé par type vers {output_dir}")
        
        try:
            import os
            os.makedirs(output_dir, exist_ok=True)
            
            if type_column not in data.columns:
                self.logger.error(f"Colonne {type_column} non trouvée")
                return False
            
            # Grouper par type et exporter
            exported_count = 0
            for data_type, group in data.groupby(type_column):
                output_path = os.path.join(output_dir, f"{data_type}_data.csv")
                
                success = self.export_standard_csv(group, output_path, {
                    'data_type': data_type,
                    'n_samples': len(group)
                })
                
                if success:
                    exported_count += 1
            
            self.logger.info(f"✅ Export séparé terminé : {exported_count} fichiers créés")
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Erreur lors de l'export séparé : {e}")
            return False
    
    def export_for_bioconductor(self, data: pd.DataFrame, 
                               output_path: str,
                               feature_column: str = 'gene_id') -> bool:
        """
        Exporte au format compatible Bioconductor/R
        
        Args:
            data: Données à exporter
            output_path: Chemin de sortie
            feature_column: Colonne des features (gènes)
        
        Returns:
            True si succès, False sinon
        """
        self.logger.info(f"Export format Bioconductor vers {output_path}")
        
        try:
            if feature_column not in data.columns:
                self.logger.error(f"Colonne feature {feature_column} non trouvée")
                return False
            
            # Mettre les features en index pour format matriciel
            bioconductor_data = data.set_index(feature_column)
            
            # Garder seulement les colonnes numériques
            numeric_cols = bioconductor_data.select_dtypes(include=[np.number]).columns
            bioconductor_data = bioconductor_data[numeric_cols]
            
            # Exporter avec point comme séparateur décimal pour compatibilité R
            bioconductor_data.to_csv(output_path, 
                                   sep=self.separator,
                                   header=True,
                                   index=True,
                                   decimal='.')  # Point pour R
            
            self.logger.info(f"✅ Export Bioconductor terminé : {output_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"❌ Erreur lors de l'export Bioconductor : {e}")
            return False
    
    def _generate_data_dictionary(self, data: pd.DataFrame) -> Dict[str, str]:
        """Génère automatiquement un dictionnaire de données"""
        dictionary = {}
        
        for col in data.columns:
            dtype = str(data[col].dtype)
            
            # Générer une description basée sur le nom et le type
            if 'id' in col.lower() or 'patient' in col.lower():
                description = f"Identifiant unique de l'échantillon ({col})"
            elif any(gene_term in col.lower() for gene_term in ['gene', 'tp53', 'brca', 'egfr']):
                description = f"Expression du gène {col} (valeurs normalisées)"
            elif any(clinical_term in col.lower() for clinical_term in ['age', 'stage', 'grade', 'survival']):
                description = f"Variable clinique : {col}"
            else:
                description = f"Variable {col} de type {dtype}"
            
            dictionary[col] = description
        
        return dictionary
    
    def export_with_validation(self, data: pd.DataFrame, 
                              output_path: str,
                              validation_rules: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Exporte avec validation des données
        
        Args:
            data: Données à exporter
            output_path: Chemin de sortie
            validation_rules: Règles de validation
        
        Returns:
            Rapport de validation et export
        """
        self.logger.info(f"Export avec validation vers {output_path}")
        
        validation_report = {
            'validation_successful': True,
            'warnings': [],
            'errors': [],
            'export_successful': False
        }
        
        try:
            # Validation basique
            if data.empty:
                validation_report['errors'].append("Dataset vide")
                validation_report['validation_successful'] = False
            
            if data.isnull().all().all():
                validation_report['errors'].append("Toutes les valeurs sont manquantes")
                validation_report['validation_successful'] = False
            
            # Vérifier les règles de validation personnalisées
            if validation_rules:
                for col, rule in validation_rules.items():
                    if col in data.columns:
                        if 'min' in rule and data[col].min() < rule['min']:
                            validation_report['warnings'].append(f"{col} : valeurs inférieures au minimum")
                        
                        if 'max' in rule and data[col].max() > rule['max']:
                            validation_report['warnings'].append(f"{col} : valeurs supérieures au maximum")
            
            # Exporter si validation OK
            if validation_report['validation_successful']:
                export_success = self.export_standard_csv(data, output_path)
                validation_report['export_successful'] = export_success
            
            return validation_report
            
        except Exception as e:
            validation_report['errors'].append(f"Erreur lors de la validation : {e}")
            validation_report['validation_successful'] = False
            return validation_report

# Tests rapides
if __name__ == "__main__":
    # Créer des données de test
    test_data = pd.DataFrame({
        'patient_id': ['P001', 'P002', 'P003'],
        'TP53': [1.5, 2.3, 0.8],
        'BRCA1': [2.1, 1.9, 3.2],
        'age': [45, 50, 55],
        'stage': ['I', 'II', 'I']
    })
    
    print("=== TEST CSV EXPORTER ===")
    print("Données originales :")
    print(test_data)
    
    # Test export standard
    exporter = CSVExporter(separator='\t')
    success = exporter.export_standard_csv(test_data, 'test_export.csv', {
        'source': 'multi_omics_pipeline',
        'version': '1.0'
    })
    
    print(f"\nExport standard : {'✅ Succès' if success else '❌ Échec'}")
    
    # Test export avec dictionnaire
    success_dict = exporter.export_with_data_dictionary(test_data, 'test_with_dict.csv')
    print(f"Export avec dictionnaire : {'✅ Succès' if success_dict else '❌ Échec'}")
    
    # Lire et vérifier le fichier exporté
    try:
        with open('test_export.csv', 'r') as f:
            content = f.read()
        
        print(f"\nAperçu du fichier CSV :")
        print(content[:200] + "..." if len(content) > 200 else content)
        
    except Exception as e:
        print(f"Erreur lors de la lecture du fichier : {e}")